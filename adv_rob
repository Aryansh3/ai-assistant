import threading
import re
import requests
import speech_recognition as sr
import pyttsx3
import random

# CONFIGURATION

PERPLEXITY_API_KEY = "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"  
PERPLEXITY_API_URL = "https://api.perplexity.ai/chat/completions"
MODEL_NAME = "sonar-pro"


# SPEAKING & INTERRUPT SUPPORT

speak_thread = None
speaking_engine = None
stop_speaking_flag = False

def speak(text):
    global speaking_engine, stop_speaking_flag
    speaking_engine = pyttsx3.init()
    speaking_engine.setProperty('rate', 160)
    speaking_engine.setProperty('volume', 1.0)
    text_to_say = f". {text}"
    stop_speaking_flag = False
    def check_stop(name, completed):
        if stop_speaking_flag and speaking_engine is not None:
            speaking_engine.stop()
    speaking_engine.connect('started-word', check_stop)
    print(f"AI says: {text}")
    speaking_engine.say(text_to_say)
    speaking_engine.runAndWait()
    speaking_engine = None

def stop_speaking():
    global stop_speaking_flag, speaking_engine
    stop_speaking_flag = True
    if speaking_engine is not None:
        speaking_engine.stop()

def speak_in_thread(text):
    global speak_thread
    if speak_thread and speak_thread.is_alive():
        stop_speaking()
        speak_thread.join()
    speak_thread = threading.Thread(target=speak, args=(text,))
    speak_thread.start()


# LISTEN FUNCTION

def listen():
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        print("\nListening...")
        recognizer.adjust_for_ambient_noise(source, duration=1)
        audio = recognizer.listen(source)
        try:
            text = recognizer.recognize_google(audio)
            print(f"You said: {text}")
            return text.strip()
        except sr.UnknownValueError:
            speak_in_thread("Sorry, I didn't catch that. Please say it again.")
            return ""
        except sr.RequestError:
            speak_in_thread("Sorry, I am having trouble connecting to the speech service.")
            return ""




def listen_with_specific_interrupt(interrupt_keywords=None):
    """
    Continuously listens for interrupt keywords.
    Returns True only when a valid interrupt word is recognized.
    All other input (including silence/noise/other words) is ignored.
    """
    if interrupt_keywords is None:
        interrupt_keywords = ["interrupt", "cancel", "pause", "wait", "shut up"]
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        recognizer.adjust_for_ambient_noise(source, duration=0.5)
        print(f"Listening for interrupt words:")
        while True:
            audio = recognizer.listen(source)
            try:
                text = recognizer.recognize_google(audio).lower().strip()
                print(f"interrupt listener: {text}")
                if any(kw in text for kw in interrupt_keywords):
                    print("Interrupt keyword detected!")
                    return True
            except sr.UnknownValueError:
                continue  # Ignore unrecognized sounds (noise/silence)
            except sr.RequestError:
                print("Speech service unavailable for interruption check.")
                break
        return False




# INTENT CLASSIFICATION (NLU)

def get_intent_from_nlu(user_input):
    prompt = (
        "Classify the intent of this message into one of these labels only "
        "(no explanation): "
        "['greeting', 'goodbye', 'thank_you', 'pause', 'interrupt', 'repeat', "
        "'clarify', 'joke', 'personal_question', 'provide_name', 'opinion', "
        "'weather_query', 'time_query', 'date_query', 'question', 'unknown'].\n"
        f"Message: '{user_input}'.\n"
        "Respond with only the intent label."
    )
    intent = query_perplexity(prompt)
    return intent.lower().strip()


# USER NAME EXTRACTION (from "My name is ..." statements)

def extract_user_name(user_input):
    prompt = (
        "Extract the user's name from the following message if they provide it. "
        "If there is no name, reply 'None'.\n"
        f"Message: '{user_input}'.\n"
        "Respond with only the name or 'None'."
    )
    name = query_perplexity(prompt)
    name = name.strip()
    if name.lower() == "none" or not name.isalpha():
        return None
    return name


# PERPLEXITY API QUERY

def query_perplexity(prompt):
    headers = {
        "Authorization": f"Bearer {PERPLEXITY_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": MODEL_NAME,
        "messages": [
            {"role": "system", "content": "You are Lixus, a friendly, conversational AI assistant. Speak like a helpful, kind friend. If you don't know something, admit it politely."},
            {"role": "user", "content": prompt}
        ],
        "stream": False
    }
    try:
        response = requests.post(PERPLEXITY_API_URL, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        answer = result["choices"][0]["message"]["content"].strip()
        return answer
    except Exception as e:
        return f"Sorry, there was an error getting the answer: {e}"


# CLEAN TEXT FOR TTS

def clean_text(text):
    text = re.sub(r'[\*\#\_\`\\]', '', text)
    text = re.sub(r'\[\d+\]', '', text)
    return text.strip()


# INTERRUPT WATCHER THREAD

def interrupt_watcher():
    if listen_with_specific_interrupt():
        stop_speaking()


# FRIENDLY, PERSONALIZED RESPONSE LISTS

greeting_responses = [
    "Fine! How can I help you today?",
    "Fine there! What can I do for you?",
    "Fine! Ready to assist you."
]
thank_responses = [
    "You're welcome!",
    "No problem at all.",
    "Happy to help you!"
]
personal_responses = [
    "I'm Lixus, your helpful assistant!",
    "You can call me Lixus. I love helping people.",
    "I'm just an AI, but I try to be a good friend."
]
name_templates = [
    "Nice to meet you, {name}!",
    "Hi {name}, I'm Lixus. How can I help today?",
    "Pleased to meet you, {name}. Let me know what you need."
]


# MAIN LOGIC WITH CONTEXT MEMORY & FRIENDLY DIALOG

def main():
    global speak_thread

    # Dialog memory/context (last 5 turns)
    dialog_history = []
    user_name = None

    speak_in_thread("Hello! I am Lixus, your assistant. What's your name or how can I help?")

    while True:
        user_input = listen()
        if not user_input:
            continue

        intent = get_intent_from_nlu(user_input)
        print(f"> Detected intent: {intent}")

        # Check for name introduction
        if intent == "provide_name":
            name = extract_user_name(user_input)
            if name:
                user_name = name
                reply = random.choice(name_templates).format(name=name)
                speak_in_thread(reply)
                dialog_history.append({'user': user_input, 'assistant': reply})
                continue

        # Greetings
        if intent == "greeting":
            if user_name:
                reply = f"Fine, {user_name}! How can I help you today?"
            else:
                reply = random.choice(greeting_responses)
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Goodbye
        if intent == "goodbye":
            stop_speaking()
            reply = f"Goodbye{', ' + user_name if user_name else ''}! Have a nice day."
            speak_in_thread(reply)
            if speak_thread:
                speak_thread.join()
            break

        # Thank you
        if intent == "thank_you":
            reply = random.choice(thank_responses)
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Pause/Interrupt
        if intent in ["pause", "interrupt"]:
            stop_speaking()
            reply = "Okay, I will wait now..."
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Repeat
        if intent == "repeat":
            if dialog_history:
                reply = f"I said: {dialog_history[-1]['assistant']}"
            else:
                reply = "I don't have anything to repeat yet."
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Clarify
        if intent == "clarify":
            if dialog_history:
                reply = f"You last asked: {dialog_history[-1]['user']}. What would you like me to clarify?"
            else:
                reply = "I don't have a previous question to clarify."
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Joke
        if intent == "joke":
            context = ""
            for turn in dialog_history[-3:]:
                context += f"User: {turn['user']}\nAssistant: {turn['assistant']}\n"
            if user_name:
                context = f"(The user's name is {user_name}.)\n" + context
            full_prompt = context + f"User: {user_input}\nAssistant:"
    
            answer = query_perplexity(full_prompt)
            cleaned_answer = clean_text(answer)
            dialog_history.append({'user': user_input, 'assistant': cleaned_answer})
            dialog_history = dialog_history[-5:]  # Only keep last 5 exchanges
    
            # Speak answer in a thread and allow interruption
            tts_thread = threading.Thread(target=speak, args=(cleaned_answer,))
            interrupt_thread = threading.Thread(target=interrupt_watcher)
            tts_thread.start()
            interrupt_thread.start()
            tts_thread.join()

        # Personal question
        if intent == "personal_question":
            reply = random.choice(personal_responses)
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Opinion
        if intent == "opinion":
            reply = "I don't have personal opinions, but I can definitely help you gather information to make your own choice!"
            speak_in_thread(reply)
            dialog_history.append({'user': user_input, 'assistant': reply})
            continue

        # Weather/Time/Date queries could be routed to specific APIs (future improvement)
        if intent in ["weather_query", "time_query", "date_query"]:
            context = ""
            for turn in dialog_history[-3:]:
                context += f"User: {turn['user']}\nAssistant: {turn['assistant']}\n"
            if user_name:
                context = f"(The user's name is {user_name}.)\n" + context
            full_prompt = context + f"User: {user_input}\nAssistant:"

            answer = query_perplexity(full_prompt)
            cleaned_answer = clean_text(answer)
            dialog_history.append({'user': user_input, 'assistant': cleaned_answer})
            dialog_history = dialog_history[-5:]  # Only keep last 5 exchanges

            # Speak answer in a thread and allow interruption
            tts_thread = threading.Thread(target=speak, args=(cleaned_answer,))
            interrupt_thread = threading.Thread(target=interrupt_watcher)
            tts_thread.start()
            interrupt_thread.start()
            tts_thread.join()

        # All other: handle as general question with dialog context for LLM
        # Compose recent context (last 3 exchanges) for better conversation
        context = ""
        for turn in dialog_history[-3:]:
            context += f"User: {turn['user']}\nAssistant: {turn['assistant']}\n"
        if user_name:
            context = f"(The user's name is {user_name}.)\n" + context
        full_prompt = context + f"User: {user_input}\nAssistant:"

        answer = query_perplexity(full_prompt)
        cleaned_answer = clean_text(answer)
        dialog_history.append({'user': user_input, 'assistant': cleaned_answer})
        dialog_history = dialog_history[-5:]  # Only keep last 5 exchanges

        # Speak answer in a thread and allow interruption
        tts_thread = threading.Thread(target=speak, args=(cleaned_answer,))
        interrupt_thread = threading.Thread(target=interrupt_watcher)
        tts_thread.start()
        interrupt_thread.start()
        tts_thread.join()

if __name__ == "__main__":
    main()
